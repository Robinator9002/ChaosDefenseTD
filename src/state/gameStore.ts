// src/state/gameStore.ts

import { create, type StoreApi } from 'zustand';
import { v4 as uuidv4 } from 'uuid';
import type {
    GameState,
    AppStatus,
    EnemyInstance,
    TowerInstance,
    Vector2D,
    WaveState,
} from '../types/game';
import type { EnemyTypeConfig } from '../types/configs';
import WaveManager from '../services/WaveManager';
import ConfigService from '../services/ConfigService';

// This is a placeholder path. In a real game, this would be generated by the LevelManager.
const DUMMY_PATH: Vector2D[] = [
    { x: 0, y: 10 },
    { x: 5, y: 10 },
    { x: 10, y: 10 },
    { x: 10, y: 5 },
    { x: 15, y: 5 },
    { x: 20, y: 5 },
    { x: 20, y: 10 },
    { x: 20, y: 15 },
];

export interface GameActions {
    setAppStatus: (status: AppStatus) => void;
    addGold: (amount: number) => void;
    removeHealth: (amount: number) => void;
    setWaveState: (waveState: Partial<WaveState>) => void;
    spawnEnemy: (config: EnemyTypeConfig, path: Vector2D[]) => void;
    initializeGameSession: () => void; // New action to set up a game
    update: (dt: number) => void;
}

// Add manager instances to the GameState
export interface GameStateWithManagers extends GameState {
    waveManager: WaveManager | null;
}

const initialState: GameStateWithManagers = {
    appStatus: 'main-menu',
    gold: 200,
    health: 25,
    currentWave: 0,
    waveState: {
        waveInProgress: false,
        timeToNextWave: 10,
        spawnQueue: [],
        spawnCooldown: 0,
    },
    enemies: {},
    towers: {},
    projectiles: {},
    selectedTowerForBuild: null,
    selectedTowerInstanceId: null,
    // Managers start as null
    waveManager: null,
};

export const useGameStore = create<GameStateWithManagers & GameActions>((set, get) => ({
    ...initialState,

    setAppStatus: (status: AppStatus) => set({ appStatus: status }),
    addGold: (amount: number) => set((state) => ({ gold: state.gold + amount })),
    removeHealth: (amount: number) =>
        set((state) => ({ health: Math.max(0, state.health - amount) })),
    setWaveState: (waveState: Partial<WaveState>) => {
        set((state) => ({ waveState: { ...state.waveState, ...waveState } }));
    },
    spawnEnemy: (config: EnemyTypeConfig, path: Vector2D[]) => {
        const newEnemy: EnemyInstance = {
            id: uuidv4(),
            config,
            path,
            position: { ...path[0] },
            currentHp: config.base_stats.hp,
            pathIndex: 0,
            effects: [],
            currentSpeed: config.base_stats.speed,
            currentArmor: config.base_stats.armor,
        };
        set((state) => ({
            enemies: { ...state.enemies, [newEnemy.id]: newEnemy },
        }));
    },

    /**
     * Sets up the logic managers for a new game session.
     * This should ONLY be called after ConfigService is initialized.
     */
    initializeGameSession: () => {
        if (!ConfigService.configs) {
            console.error('Cannot initialize game session: Configs are not loaded.');
            return;
        }
        console.log('Initializing game session and creating managers...');
        const waveManager = new WaveManager(ConfigService.configs, DUMMY_PATH);
        set({ waveManager: waveManager, appStatus: 'in-game' });
    },

    update: (dt: number) => {
        const { appStatus, waveManager } = get();
        if (appStatus !== 'in-game') return;

        // Delegate update logic to the responsible manager if it exists
        if (waveManager) {
            waveManager.update(get, set, dt);
        }
    },
}));
